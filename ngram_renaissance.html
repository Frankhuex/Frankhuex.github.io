<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>N-Gram æ–‡è‰ºå¤å…´</title>
    <style>
        /* --- 1. å…¨å±€ä¸é‡ç½® --- */
        * { box-sizing: border-box; }

        body {
            /* å®šä¹‰ä¸€å¥—ç¾è§‚çš„ç³»ç»Ÿå­—ä½“æ ˆ */
            font-family: 'Segoe UI', 'Microsoft YaHei', 'PingFang SC', "Apple Color Emoji", "Segoe UI Emoji", sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            color: #333;
            line-height: 1.6;
            height: 100vh;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
        }

        /* --- 2. å¸ƒå±€å®¹å™¨ --- */
        .app-container {
            width: 100%;
            height: 100%;
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        /* å·¦ä¾§é¢æ¿ */
        .left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            min-width: 0;
        }

        /* å³ä¾§é¢æ¿ */
        .right-panel {
            flex: 1.2;
            display: flex;
            flex-direction: column;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            min-width: 0;
        }

        h1 { margin: 0 0 10px 0; text-align: center; color: #2c3e50; font-size: 1.5rem; letter-spacing: 1px; }
        h2 { margin: 0 0 10px 0; font-size: 1.1rem; color: #34495e; border-bottom: 2px solid #eee; padding-bottom: 5px; }

        /* --- 3. ç»„ä»¶æ ·å¼ --- */

        /* å¼ºåˆ¶ Textarea ä½¿ç”¨æ ‡å‡†å­—ä½“ */
        textarea {
            font-family: 'Segoe UI', 'Microsoft YaHei', 'PingFang SC', sans-serif !important;
            letter-spacing: normal;
        }

        /* è¯­æ–™è¾“å…¥æ¡† */
        #corpusInput {
            flex-grow: 1;
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            resize: none;
            overflow-y: auto;
            margin-bottom: 10px;
            
            /* ç»Ÿä¸€å­—ä½“å¤§å°ä¸è¡Œé«˜ */
            font-size: 1rem; 
            line-height: 1.5;
        }
        #corpusInput:focus { border-color: #3498db; outline: none; }

        .train-actions {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
        }

        /* è¾“å‡ºæ¡† */
        .output-wrapper {
            flex-grow: 1;
            border: 2px solid #b2bec3;
            border-radius: 6px;
            background-color: #2d3436;
            margin-bottom: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .output-box {
            flex-grow: 1;
            padding: 15px;
            color: #dfe6e9;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; 
            font-size: 1.1rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
            user-select: text;
            cursor: text;
        }

        /* ä¸­é—´æ§åˆ¶æ  */
        .middle-controls {
            flex-shrink: 0;
            background: #f1f2f6;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #dfe6e9;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: space-between;
        }

        .control-group { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }

        /* åº•éƒ¨è¾“å…¥åŒº */
        .input-area {
            flex-shrink: 0;
            display: flex;
            align-items: flex-end;
            gap: 10px;
            background: #ecf0f1;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #bdc3c7;
        }

        #userCharInput {
            flex-grow: 1;
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            outline: none;
            resize: none;
            overflow-y: auto;
            
            /* ç»Ÿä¸€å­—ä½“å¤§å° */
            font-size: 1rem;
            line-height: 1.5;

            /* æ¡Œé¢ç«¯é«˜åº¦ */
            height: auto; 
            min-height: 48px;
            max-height: 130px; 
        }
        #userCharInput:focus { border-color: #3498db; }

        /* æŒ‰é’®æ ·å¼ */
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.1s;
            font-size: 0.9rem;
            white-space: nowrap;
            touch-action: manipulation; /* ç¦ç”¨ç¼©æ”¾ */
            user-select: none;
            -webkit-user-select: none;
        }
        
        button:active { transform: scale(0.98); }
        button:hover { background-color: #2980b9; }
        button.action-btn { background-color: #27ae60; }
        button.action-btn:hover { background-color: #219150; }

        .setting-group {
            display: flex; align-items: center; gap: 5px; font-size: 0.9rem;
            background: #fff; padding: 4px 8px; border: 1px solid #bdc3c7; border-radius: 4px;
        }
        .setting-group input[type="number"] {
            width: 45px; border: none; border-bottom: 1px solid #bdc3c7; text-align: center; outline: none;
            font-family: inherit;
        }
        .switch-label { display: flex; align-items: center; cursor: pointer; font-weight: bold; font-size: 0.9rem; }
        .switch-label input { margin-right: 6px; }

        /* æ–‡æœ¬æ ‡è®°é¢œè‰² */
        .text-user { color: #ff7675; font-weight: bold; }
        .text-model { color: #55efc4; }
        .text-cursor {
            display: inline-block; width: 8px; height: 1.2rem; background-color: #dfe6e9;
            animation: blink 1s infinite; vertical-align: middle; margin-left: 2px;
        }
        @keyframes blink { 50% { opacity: 0; } }
        .topic-divider {
            border: 0; height: 1px; background-image: linear-gradient(to right, rgba(0,0,0,0), rgba(255,255,255,0.5), rgba(0,0,0,0));
            margin: 20px 0; position: relative; width: 100%;
        }
        .topic-divider::after {
            content: "æ–°è¯é¢˜"; position: absolute; left: 50%; top: -10px; transform: translateX(-50%);
            background: #2d3436; padding: 0 10px; color: #b2bec3; font-size: 0.8rem;
        }

        /* --- 4. ç§»åŠ¨ç«¯é€‚é… --- */
        @media (max-width: 768px) {
            body { height: auto; overflow-y: auto; }
            
            .app-container { 
                flex-direction: column; 
                padding: 5px; 
                gap: 15px; 
            }
            
            .left-panel, .right-panel { width: 100%; padding: 10px; box-shadow: none; border: 1px solid #eee; }
            #corpusInput { flex-grow: 0; min-height: 100px; max-height: 240px; }
            .output-wrapper { flex-grow: 0; height: auto; }
            .output-box { min-height: 120px; max-height: 250px; }
            h1 { font-size: 1.2rem; }
            .middle-controls { flex-direction: column; align-items: stretch; gap: 10px; }
            .control-group { justify-content: space-between; }
        }

        /* æ»šåŠ¨æ¡ç¾åŒ– */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
        ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
        .output-box::-webkit-scrollbar-track { background: #2d3436; }
        .output-box::-webkit-scrollbar-thumb { background: #636e72; }
    </style>
</head>
<body>

<div class="app-container">
    
    <!-- å·¦ä¾§ï¼šè¯­æ–™é¢æ¿ -->
    <div class="left-panel">
        <h2>ğŸ“‚ è®­ç»ƒè¯­æ–™</h2>
        <textarea id="corpusInput" class="corpus-auto-mobile" placeholder="åœ¨æ­¤ç²˜è´´è¯­æ–™...">
æ­»äººäº†ï¼Œå¾å¯æ˜Ÿä¸æ˜¯ç¬¬ä¸€ä¸ªå‘ç°çš„ï¼Œç¬¬ä¸€ä¸ªå‘ç°çš„æ˜¯æ­»äº†çš„é‚£ä¸ªï¼Œå¯æ˜¯å¥¹æ­»äº†ï¼Œäºæ˜¯ç¬¬äºŒä¸ªæˆäº†ç¬¬ä¸€ä¸ªï¼Œå› ä¸ºç¬¬ä¸€ä¸ªå·²ç»æ­»äº†ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨ç¬¬äºŒä¸ªä¹‹å‰çš„ç¬¬ä¸€ä¸ªæ¶ˆå¤±äº†ï¼Œç¬¬äºŒä¸ªæ‰æœ‰æœºä¼šæˆä¸ºç¬¬ä¸€ä¸ªï¼ŒæŒ¤æ‰ç¬¬ä¸€ä¸ªçš„ä½ç½®ï¼Œä¸ç„¶ç¬¬äºŒä¸ªæ˜¯ä¸èƒ½å˜æˆç¬¬ä¸€ä¸ªã€‚è¿™ä¸ªé“ç†å’Œä¸¤ä¸ªäººåœ¨ä¸€èµ·ï¼Œä¸€ä¸ªäººçŒæ­»äº†ï¼Œå…¶å®å‘ç°å¥¹æ­»äº†çš„æ˜¯æ­»äº†çš„å¥¹ï¼Œå¦ä¸€ä¸ªäººæ˜¯ç¬¬äºŒä¸ªï¼Œå¯æ˜¯ç¬¬ä¸€ä¸ªäººæ­»äº†ï¼Œäºæ˜¯ç¬¬äºŒä¸ªå°±æˆäº†ç¬¬ä¸€ä¸ªï¼Œé“ç†æ˜¯ä¸€æ ·çš„ã€‚
å¾å¯æ˜Ÿçªç„¶é—´æƒ³é€šäº†è¿™ä¸ªæƒŠä¸–éª‡ä¿—çš„é“ç†ã€‚å¤§å®¶åªä¼šè®°å¾—ç¬¬ä¸€ä¸ªäººï¼Œè€Œä¸ä¼šæƒ³èµ·ç¬¬äºŒä¸ªäºº.å› æ­¤å¤§å®¶å¯¹ä¸€ä¸ªäººçš„é€å»æ„Ÿåˆ°æ— æ¯”æ‚²ç—›ï¼Œå› ä¸ºä»–æ˜¯ç¬¬ä¸€ä¸ªå‘ç°è‡ªå·±æ­»äº†çš„äººã€‚è€Œå¯¹äºå‘ç°ä»–æ­»äº†çš„ç¬¬äºŒä¸ªäººï¼Œå¤§å®¶å¯èƒ½è¿˜ä¼šè´£æ€ªä»–ä¸ºä»€ä¹ˆä¸æ—©ç‚¹å‘ç°ã€‚é‚£ç¬¬äºŒä¸ªäººè™½ç„¶æœ€åæˆä¸ºäº†ä»–äººçœ¼ä¸­çš„å¦ä¸€ä¸ªå‘ç°é‚£ä¸ªäººæ­»äº†çš„äººï¼Œä½†ä»–è¿˜ä¼šè¢«è‡ªå·±å¿ƒä¸­çš„å†…ç–šå›°æ‰°å¾ˆä¹…ï¼Œå¯¹è‡ªå·±ç¬¬ä¸€ä¸ªçš„ä½ç½®æ„Ÿåˆ°æ— æ¯”æ‚”æ¨ã€‚ä»–æˆä¸ºäº†å¦ä¸€ä¸ªï¼Œä½†ä»–çš„å†…å¿ƒæ— æ³•æ¥å—è¿™ä¸ªäº‹å®ã€‚è¿™å°±æ˜¯ç¬¬äºŒä¸ªå‘ç°åˆ«äººæ­»çš„å’Œç¬¬ä¸€ä¸ªå‘ç°çš„åŒºåˆ«ï¼Œé«˜ä¸‹ç«‹åˆ¤ã€‚
ç„¶è€Œï¼Œå¾å¯æ˜Ÿå‘ç°äº‹å®å¹¶éå¦‚æ­¤ã€‚å®é™…ä¸Šï¼Œå¤§å®¶å¯¹æ­»äº†çš„äººçš„æ­»æ„Ÿåˆ°éå¸¸é«˜å…´ï¼Œå› ä¸ºå¥¹è¯•å›¾æˆä¸ºç¬¬ä¸€ä¸ªå‘ç°è‡ªå·±æ­»äº†çš„äººï¼Œè¯•å›¾ä¸å…¶ä»–äººäº‰å¤ºè¿™ä¸ªè£èª‰ï¼Œä½†ç¬¬äºŒä¸ªæŒ«è´¥äº†å¥¹çš„è®¡åˆ’ï¼ŒæŒ¤æ‰äº†å¥¹åŸæœ¬ç¬¬ä¸€çš„ä½ç½®ï¼Œä½¿å¥¹æ— æ³•å¾—é€ï¼Œä¸å¾—ä¸è¯´è¿™çœŸæ˜¯å¤§å¿«äººå¿ƒã€‚è€Œé‚£åŸæœ¬æ˜¯ç¬¬äºŒä¸ªå‘ç°å¥¹æ­»çš„äººç°åœ¨æŒ«è´¥äº†æ­»è€…çš„è®¡åˆ’ï¼Œæˆä¸ºäº†ç¬¬ä¸€ä¸ªï¼Œä¹Ÿå°±ç†æ‰€å½“ç„¶æˆä¸ºäº†æŒ«è´¥é‚£ç‹‚å¦„çš„è¯•å›¾å¤ºå–ç¬¬ä¸€è£èª‰çš„æ­»è€…çš„å‘åŠ£è®¡åˆ’çš„è‹±é›„ï¼Œå—ç€ä¼—äººçš„æ™¯ä»°ã€‚
æ‰€ä»¥ï¼Œç¬¬ä¸€ä¸ªäººæ­»äº†è€Œç¬¬äºŒä¸ªäººæƒ³æ˜ç™½äº†å’Œç¬¬äºŒä¸ªäººæƒ³æ˜ç™½äº†è€Œç¬¬ä¸€ä¸ªäººæ­»äº†ä¸€æ¨¡ä¸€æ ·ã€‚        </textarea>
        
        <div class="train-actions">
            <div id="trainStatus" style="font-size:0.85rem; color:#e74c3c; margin-right:10px;">æœªè®­ç»ƒ</div>
            <button onclick="trainModels()">ğŸš€ è®­ç»ƒæ¨¡å‹</button>
        </div>
    </div>

    <!-- å³ä¾§ï¼šäº¤äº’é¢æ¿ -->
    <div class="right-panel">
        <h1>N-Gram æ–‡è‰ºå¤å…´</h1>

        <!-- 1. è¾“å‡ºå±å¹• -->
        <div class="output-wrapper">
            <div id="consoleOutput" class="output-box" onclick="focusInputIfEmptySelection()">
                <div style="color:#b2bec3; text-align:center; padding-top:20px; font-style:italic;">
                    è¯·å…ˆç‚¹å‡»å·¦ä¾§â€œè®­ç»ƒæ¨¡å‹â€ï¼Œç„¶ååœ¨æ­¤å¤„å¼€å§‹åˆ›ä½œ...
                </div>
            </div>
        </div>

        <!-- 2. ä¸­é—´æ§åˆ¶æ  -->
        <div class="middle-controls">
            <div class="control-group">
                <div>
                    <input type="radio" id="modelBigram" name="modelType" value="bigram"> <label for="modelBigram">Bigram</label>
                    <input type="radio" id="modelTrigram" name="modelType" value="trigram" checked> <label for="modelTrigram">Trigram</label>
                </div>
                <label class="switch-label" title="å»¶ç»­ä¸Šæ–‡">
                    <input type="checkbox" id="continuousMode" checked> ğŸ”— è¿ç»­
                </label>
            </div>

            <div class="control-group">
                <div class="setting-group" title="AIæ¯æ¬¡ç”Ÿæˆçš„å­—æ•°">
                    <label>AIå­—æ•°:</label>
                    <input type="number" id="aiCount" value="1" min="1" max="100">
                </div>
                <button class="action-btn" onclick="triggerRandomGeneration()">ğŸ² éšæœºç”Ÿæˆ</button>
            </div>
        </div>

        <!-- 3. åº•éƒ¨è¾“å…¥æ  -->
        <div class="input-area">
            <textarea id="userCharInput" placeholder="è¾“å…¥æ–‡å­— (Enterå‘é€ï¼ŒCtrl+Enteræ¢è¡Œ)..."></textarea>
            <button onclick="processInput()" style="height: auto; align-self: stretch; font-weight:bold;">å‘é€</button>
        </div>
        
        <div style="text-align:right; font-size:0.8rem; color:#999; margin-top:5px;">
             å¿«æ·é”®: Enter å‘é€ / Ctrl+Enter æ¢è¡Œ
        </div>
    </div>
</div>

<script>
// --- å“åº”å¼é«˜åº¦è°ƒæ•´é€»è¾‘ ---
function initResponsiveResize() {
    const userResultBox = document.getElementById('userCharInput');
    const corpusBox = document.getElementById('corpusInput');

    function setHeight(el) {
        el.style.height = 'auto'; 
        if (el.id === 'corpusInput' && window.innerWidth > 768) {
            el.style.height = '100%'; 
            return;
        }
        let newHeight = el.scrollHeight;
        el.style.height = newHeight + 'px';
    }

    userResultBox.addEventListener('input', () => setHeight(userResultBox));
    corpusBox.addEventListener('input', () => setHeight(corpusBox));

    window.addEventListener('resize', () => {
        if (window.innerWidth > 768) {
            corpusBox.style.height = ''; 
        } else {
            setHeight(corpusBox);
        }
        setHeight(userResultBox);
    });

    if (window.innerWidth <= 768) setHeight(corpusBox);
    setHeight(userResultBox);
}
window.addEventListener('DOMContentLoaded', initResponsiveResize);


// --- N-Gram ç®—æ³•æ ¸å¿ƒ ---
class Counter extends Map {
    get(key) { return super.get(key) || 0; }
    add(key, val = 1) { this.set(key, this.get(key) + val); }
}

function weightedRandom(choices, weights) {
    let total = weights.reduce((a, b) => a + b, 0);
    let randomVal = Math.random() * total;
    let cumulative = 0;
    for (let i = 0; i < choices.length; i++) {
        cumulative += weights[i];
        if (randomVal < cumulative) return choices[i];
    }
    return choices[choices.length - 1]; 
}

class SimpleNGramLMBase {
    constructor() {
        this.vocab = new Set();
        this.unigram_counts = new Counter();
        this.bigram_counts = new Map(); 
        this.trigram_counts = new Map();
        this.smoothing = 1.0;
        this.vocab_size = 0;
    }
    get_bigram_count(w1, w2) {
        if (!this.bigram_counts.has(w1)) return 0;
        return this.bigram_counts.get(w1).get(w2);
    }
    get_trigram_count(w1, w2, w3) {
        let key = w1 + "|" + w2;
        if (!this.trigram_counts.has(key)) return 0;
        return this.trigram_counts.get(key).get(w3);
    }
    getRandomChar() {
        let validChars = Array.from(this.vocab).filter(c => c !== '<s>' && c !== '</s>');
        if (validChars.length === 0) return ' '; 
        return validChars[Math.floor(Math.random() * validChars.length)];
    }
}

class SimpleBigramLM extends SimpleNGramLMBase {
    train(corpus) {
        for (let i = 0; i < corpus.length; i++) {
            let word = corpus[i];
            this.vocab.add(word);
            this.unigram_counts.add(word);
            if (i < corpus.length - 1) {
                let next_word = corpus[i+1];
                if (!this.bigram_counts.has(word)) this.bigram_counts.set(word, new Counter());
                this.bigram_counts.get(word).add(next_word);
            }
        }
        this.vocab_size = this.vocab.size;
    }
    get_probability(word, given_word) {
        let bigram_c = this.get_bigram_count(given_word, word) + this.smoothing;
        let unigram_c = this.unigram_counts.get(given_word) + this.smoothing * this.vocab_size;
        return bigram_c / unigram_c;
    }
    generate_word(given_word) {
        let next_counter = this.bigram_counts.get(given_word);
        let next_words = next_counter ? Array.from(next_counter.keys()) : [];
        if (next_words.length === 0) return '</s>';
        let probabilities = next_words.map(w => this.get_probability(w, given_word));
        return weightedRandom(next_words, probabilities); 
    }
}

class SimpleTrigramLM extends SimpleNGramLMBase {
    train(corpus) {
        for (let i = 0; i < corpus.length; i++) {
            let word = corpus[i];
            this.vocab.add(word);
            this.unigram_counts.add(word);
            if (i < corpus.length - 1) {
                let next_word = corpus[i+1];
                if (!this.bigram_counts.has(word)) this.bigram_counts.set(word, new Counter());
                this.bigram_counts.get(word).add(next_word);
            }
            if (i < corpus.length - 2) {
                let next_word = corpus[i+1];
                let next_next_word = corpus[i+2];
                let bigram_key = word + "|" + next_word;
                if (!this.trigram_counts.has(bigram_key)) this.trigram_counts.set(bigram_key, new Counter());
                this.trigram_counts.get(bigram_key).add(next_next_word);
            }
        }
        this.vocab_size = this.vocab.size;
    }
    get_probability(word, given_word) {
        if (Array.isArray(given_word) && given_word.length === 2) {
            let [w1, w2] = given_word;
            let trigram_c = this.get_trigram_count(w1, w2, word) + this.smoothing;
            let bigram_c = this.get_bigram_count(w1, w2) + this.smoothing * this.vocab_size;
            return trigram_c / bigram_c;
        } else {
            let bg_count = this.get_bigram_count(given_word, word) + this.smoothing;
            let ug_count = this.unigram_counts.get(given_word) + this.smoothing * this.vocab_size;
            return bg_count / ug_count;
        }
    }
    generate_word(given_word) {
        let next_words = [];
        if (Array.isArray(given_word) && given_word.length === 2) {
            let key = given_word[0] + "|" + given_word[1];
            let counter = this.trigram_counts.get(key);
            if (counter) next_words = Array.from(counter.keys());
            else return this.generate_word(given_word[1]);
        } else {
            let counter = this.bigram_counts.get(given_word);
            if (counter) next_words = Array.from(counter.keys());
        }
        if (next_words.length === 0) return '</s>';
        let probabilities = next_words.map(w => this.get_probability(w, given_word));
        return weightedRandom(next_words, probabilities);
    }
}

// --- å…¨å±€çŠ¶æ€ ---
let bigramModel = null;
let trigramModel = null;
let isTrained = false;
let sessionHistory = ['<s>']; 
let currentDOMContainer = null;

// --- ç•Œé¢é€»è¾‘ ---

function scrollToBottom() {
    const box = document.getElementById('consoleOutput');
    box.scrollTop = box.scrollHeight;
}

function updateCursor() {
    if (!currentDOMContainer) return;
    const oldCursor = document.querySelector('.text-cursor');
    if (oldCursor) oldCursor.remove();
    const cursor = document.createElement('span');
    cursor.className = 'text-cursor';
    currentDOMContainer.appendChild(cursor);
}

function ensureContainer() {
    const box = document.getElementById('consoleOutput');
    const isContinuous = document.getElementById('continuousMode').checked;
    
    const hasContent = Array.from(box.childNodes).some(n => 
        (n.nodeType === 1 && n.tagName !== 'DIV' && !n.classList?.contains('text-cursor')) || 
        (n.nodeType === 1 && n.tagName === 'DIV') 
    );
    
    if (!currentDOMContainer || (!isContinuous && hasContent)) {
        if (hasContent) {
            const oldCursor = document.querySelector('.text-cursor');
            if(oldCursor) oldCursor.remove();
            const divider = document.createElement('hr');
            divider.className = "topic-divider";
            box.appendChild(divider);
        } else {
            box.innerHTML = ''; 
        }
        currentDOMContainer = document.createElement('div');
        currentDOMContainer.style.display = "inline"; 
        sessionHistory = ['<s>'];
        box.appendChild(currentDOMContainer);
    }
}

function appendText(text, type) {
    if (!currentDOMContainer) ensureContainer();
    const span = document.createElement('span');
    span.innerText = text;
    if (type === 'user') span.className = 'text-user';
    else if (type === 'model') span.className = 'text-model';
    currentDOMContainer.appendChild(span);
}

function trainModels() {
    const text = document.getElementById('corpusInput').value;
    if (!text.trim()) { alert("è¯·è¾“å…¥è®­ç»ƒæ–‡æœ¬ï¼"); return; }
    // å¤„ç† Emoji
    let charList = ['<s>', ...Array.from(text), '</s>'];
    
    const statusEl = document.getElementById('trainStatus');
    statusEl.innerText = "è®­ç»ƒä¸­...";
    statusEl.style.color = "#f39c12";

    setTimeout(() => {
        try {
            bigramModel = new SimpleBigramLM(); bigramModel.train(charList);
            trigramModel = new SimpleTrigramLM(); trigramModel.train(charList);
            isTrained = true;
            statusEl.innerText = "å·²å°±ç»ª";
            statusEl.style.color = "#27ae60";
            
            const outBox = document.getElementById('consoleOutput');
            
            // å¦‚æœæ˜¯åˆå§‹çŠ¶æ€ï¼Œæ¸…ç©ºæ¬¢è¿è¯­
            if (outBox.innerText.includes("è¯·å…ˆç‚¹å‡»å·¦ä¾§")) {
                outBox.innerHTML = '<div style="color:gray; text-align:center; padding-top:20px;">è¾“å…¥æ–‡å­—å¼€å§‹æ¥é¾™...</div>';
            } else {
                // å¦‚æœæ˜¯é‡æ–°è®­ç»ƒï¼Œè¾“å‡ºåˆ†å‰²çº¿æç¤º
                const msg = document.createElement('div');
                msg.style.textAlign = 'center';
                msg.style.color = '#27ae60';
                msg.style.fontSize = '0.85rem';
                msg.style.margin = '15px 0';
                msg.style.borderTop = '1px dashed #444'; 
                msg.style.borderBottom = '1px dashed #444';
                msg.style.padding = '5px 0';
                msg.innerText = "--- æ¨¡å‹å·²æ›´æ–° / ä¸Šä¸‹æ–‡å·²é‡ç½® ---";
                outBox.appendChild(msg);
                outBox.scrollTop = outBox.scrollHeight;
            }

            // å…³é”®ï¼šé‡ç½®ä¸Šä¸‹æ–‡ï¼Œç¡®ä¿æ–°æ¨¡å‹ç«‹åˆ»ç”Ÿæ•ˆ
            sessionHistory = ['<s>'];
            currentDOMContainer = null;

        } catch (e) {
            alert("è®­ç»ƒå‡ºé”™ï¼š" + e.message);
            statusEl.innerText = "å‡ºé”™";
            statusEl.style.color = "red";
        }
    }, 10);
}

function getModel() {
    if (!isTrained) { alert("è¯·å…ˆç‚¹å‡»å·¦ä¾§è®­ç»ƒæ¨¡å‹ï¼"); return null; }
    return document.querySelector('input[name="modelType"]:checked').value === 'bigram' ? bigramModel : trigramModel;
}

function generateNextToken() {
    const model = getModel();
    if (!model) return null;
    let nextWord;
    try {
        if (model instanceof SimpleTrigramLM) {
            let context;
            if (sessionHistory.length >= 2) {
                context = [sessionHistory[sessionHistory.length-2], sessionHistory[sessionHistory.length-1]];
            } else {
                context = sessionHistory[sessionHistory.length-1];
            }
            nextWord = model.generate_word(context);
        } else {
            let context = sessionHistory[sessionHistory.length-1];
            nextWord = model.generate_word(context);
        }

        if (nextWord === '</s>') {
            nextWord = model.getRandomChar();
        }
        
    } catch(e) { 
        nextWord = model.getRandomChar(); 
    }
    return nextWord;
}

function triggerRandomGeneration() {
    if (!isTrained) { alert("è¯·å…ˆè®­ç»ƒæ¨¡å‹"); return; }
    ensureContainer();
    let count = parseInt(document.getElementById('aiCount').value);
    const length = (isNaN(count) || count < 1) ? 20 : count;

    for (let i = 0; i < length; i++) {
        let w = generateNextToken();
        sessionHistory.push(w);
        appendText(w, 'model');
    }
    updateCursor();
    scrollToBottom();
}

function processInput() {
    if (!isTrained) { alert("è¯·å…ˆè®­ç»ƒæ¨¡å‹"); return; }

    const inputEl = document.getElementById('userCharInput');
    const val = inputEl.value;
    if (!val) return;

    let aiCount = parseInt(document.getElementById('aiCount').value);
    if (isNaN(aiCount) || aiCount < 1) aiCount = 1;

    ensureContainer();

    const chars = Array.from(val);
    chars.forEach(c => {
        sessionHistory.push(c);
        appendText(c, 'user');
    });

    for (let i = 0; i < aiCount; i++) {
        let nextW = generateNextToken();
        sessionHistory.push(nextW);
        appendText(nextW, 'model');
    }

    updateCursor();
    scrollToBottom();

    inputEl.value = '';
    inputEl.focus();
    inputEl.style.height = 'auto';
    inputEl.style.height = inputEl.scrollHeight + 'px';
}

document.getElementById('userCharInput').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const start = this.selectionStart;
            const end = this.selectionEnd;
            const value = this.value;
            this.value = value.substring(0, start) + "\n" + value.substring(end);
            this.selectionStart = this.selectionEnd = start + 1;
            this.dispatchEvent(new Event('input')); 
        } else {
            e.preventDefault(); 
            processInput();
        }
    }
});

function focusInputIfEmptySelection() {
    const selection = window.getSelection();
    if (selection.toString().length === 0) {
        document.getElementById('userCharInput').focus();
    }
}

</script>

</body>
</html>