<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N-Gram æ–‡è‰ºå¤å…´</title>
    <style>
        /* --- 1. å…¨å±€ä¸é‡ç½® --- */
        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', "Apple Color Emoji", "Segoe UI Emoji", sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            color: #333;
            line-height: 1.6;
            /* æ¡Œé¢ç«¯é»˜è®¤ï¼šé”å®šè§†å£é«˜åº¦ï¼Œç¦æ­¢ body æ»šåŠ¨ */
            height: 100vh;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
        }

        /* --- 2. å¸ƒå±€å®¹å™¨ (å“åº”å¼æ ¸å¿ƒ) --- */
        .app-container {
            width: 100%;
            height: 100%;
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1600px; /* å¤§å±é™åˆ¶æœ€å¤§å®½ï¼Œé˜²å¤ªå®½éš¾çœ‹ */
            margin: 0 auto;
        }

        /* å·¦ä¾§é¢æ¿ï¼šè®­ç»ƒè¯­æ–™ */
        .left-panel {
            flex: 1; /* æ¡Œé¢ç«¯å  1 ä»½ */
            display: flex;
            flex-direction: column;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            min-width: 0; /* é˜²æ­¢ flex å­é¡¹æº¢å‡º */
        }

        /* å³ä¾§é¢æ¿ï¼šäº¤äº’åŒº */
        .right-panel {
            flex: 1.2; /* æ¡Œé¢ç«¯å  1.2 ä»½ï¼Œç¨å®½ä¸€ç‚¹ */
            display: flex;
            flex-direction: column;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            min-width: 0;
        }

        /* æ ‡é¢˜ */
        h1 { margin: 0 0 10px 0; text-align: center; color: #2c3e50; font-size: 1.5rem; letter-spacing: 1px; }
        h2 { margin: 0 0 10px 0; font-size: 1.1rem; color: #34495e; border-bottom: 2px solid #eee; padding-bottom: 5px; }

        /* --- 3. ç»„ä»¶æ ·å¼ --- */

        /* è¯­æ–™è¾“å…¥æ¡† (æ¡Œé¢ç«¯ï¼šæ’‘æ»¡å‰©ä½™é«˜åº¦) */
        #corpusInput {
            flex-grow: 1; /* å…³é”®ï¼šæ’‘æ»¡é«˜åº¦ */
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            resize: none;
            font-family: inherit;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        #corpusInput:focus { border-color: #3498db; outline: none; }

        /* è®­ç»ƒæŒ‰é’®å®¹å™¨ */
        .train-actions {
            display: flex;
            justify-content: flex-end; /* é å³ */
            align-items: center;
            gap: 10px;
        }

        /* è¾“å‡ºæ¡† (æ¡Œé¢ç«¯ï¼šæ’‘æ»¡å‰©ä½™é«˜åº¦) */
        .output-wrapper {
            flex-grow: 1; /* å…³é”®ï¼šæ’‘æ»¡é«˜åº¦ */
            border: 2px solid #b2bec3;
            border-radius: 6px;
            background-color: #2d3436;
            margin-bottom: 10px;
            overflow: hidden; /* å†…éƒ¨å¤„ç†æ»šåŠ¨ */
            display: flex;
            flex-direction: column;
        }

        .output-box {
            flex-grow: 1;
            padding: 15px;
            color: #dfe6e9;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto; /* å…è®¸å†…éƒ¨æ»šåŠ¨ */
            user-select: text;
            cursor: text;
        }

        /* ä¸­é—´æ§åˆ¶æ  (ç§»åˆ°äº†è¾“å‡ºæ¡†å’Œè¾“å…¥æ¡†ä¹‹é—´) */
        .middle-controls {
            flex-shrink: 0;
            background: #f1f2f6;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #dfe6e9;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: space-between;
        }

        .control-group { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }

        /* åº•éƒ¨ç”¨æˆ·è¾“å…¥åŒº */
        .input-area {
            flex-shrink: 0;
            display: flex;
            align-items: flex-end;
            gap: 10px;
            background: #ecf0f1;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #bdc3c7;
        }

        #userCharInput {
            flex-grow: 1;
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            font-size: 1rem;
            outline: none;
            font-family: inherit;
            resize: none;
            overflow-y: auto;
            line-height: 1.5;
            
            /* æ¡Œé¢ç«¯é»˜è®¤é«˜åº¦æ§åˆ¶ */
            height: auto; 
            min-height: 48px;
            max-height: 130px; /* çº¦ 5 è¡Œ (1.5em * 5 + padding) */
        }
        #userCharInput:focus { border-color: #3498db; }

        /* æŒ‰é’®ä¸è¾“å…¥æ§ä»¶é€šç”¨ */
        button {
            background-color: #3498db; color: white; border: none; padding: 8px 16px;
            border-radius: 4px; cursor: pointer; transition: background 0.2s; font-size: 0.9rem; white-space: nowrap;
        }
        button:hover { background-color: #2980b9; }
        button.action-btn { background-color: #27ae60; }
        button.action-btn:hover { background-color: #219150; }

        .setting-group {
            display: flex; align-items: center; gap: 5px; font-size: 0.9rem;
            background: #fff; padding: 4px 8px; border: 1px solid #bdc3c7; border-radius: 4px;
        }
        .setting-group input[type="number"] {
            width: 45px; border: none; border-bottom: 1px solid #bdc3c7; text-align: center; outline: none;
        }
        .switch-label { display: flex; align-items: center; cursor: pointer; font-weight: bold; font-size: 0.9rem; }
        .switch-label input { margin-right: 6px; }

        /* æ–‡æœ¬é¢œè‰² */
        .text-user { color: #ff7675; font-weight: bold; }
        .text-model { color: #55efc4; }
        .text-cursor {
            display: inline-block; width: 8px; height: 1.2rem; background-color: #dfe6e9;
            animation: blink 1s infinite; vertical-align: middle; margin-left: 2px;
        }
        @keyframes blink { 50% { opacity: 0; } }
        .topic-divider {
            border: 0; height: 1px; background-image: linear-gradient(to right, rgba(0,0,0,0), rgba(255,255,255,0.5), rgba(0,0,0,0));
            margin: 20px 0; position: relative; width: 100%;
        }
        .topic-divider::after {
            content: "æ–°è¯é¢˜"; position: absolute; left: 50%; top: -10px; transform: translateX(-50%);
            background: #2d3436; padding: 0 10px; color: #b2bec3; font-size: 0.8rem;
        }

        /* --- 4. ç§»åŠ¨ç«¯/çª„å± é€‚é… (CSS Media Query) --- */
        @media (max-width: 768px) {
            body {
                height: auto; /* è§£é™¤é«˜åº¦é”å®š */
                overflow-y: auto; /* å…è®¸å…¨å±€æ»šåŠ¨ */
            }

            .app-container {
                flex-direction: column; /* ä¸Šä¸‹å †å  */
                padding: 5px; /* æå°è¾¹è· */
                gap: 15px;
            }

            .left-panel, .right-panel {
                width: 100%;
                padding: 10px;
                box-shadow: none;
                border: 1px solid #eee;
            }

            /* è¯­æ–™æ¡†ï¼šé«˜åº¦é™åˆ¶ 4~10 è¡Œ */
            #corpusInput {
                flex-grow: 0; /* ä¸å†æ’‘æ»¡ */
                /* CSS æ§åˆ¶æœ€å¤§æœ€å°é«˜åº¦ï¼Œå…·ä½“é«˜åº¦ç”± JS auto-expand å¾®è°ƒ */
                min-height: 100px; /* çº¦ 4è¡Œ */
                max-height: 240px; /* çº¦ 10è¡Œ */
            }

            /* è¾“å‡ºæ¡†ï¼šé«˜åº¦é™åˆ¶ 4~10 è¡Œ */
            .output-wrapper {
                flex-grow: 0; /* ä¸å†æ’‘æ»¡ */
                height: auto;
            }
            .output-box {
                min-height: 120px; /* çº¦ 4-5 è¡Œ */
                max-height: 250px; /* çº¦ 10 è¡Œ */
                /* overflow-y åœ¨é€šç”¨æ ·å¼é‡Œå·²ç»æ˜¯ auto */
            }
            
            h1 { font-size: 1.2rem; }
            
            /* æ§åˆ¶æ ä¼˜åŒ– */
            .middle-controls { flex-direction: column; align-items: stretch; gap: 10px; }
            .control-group { justify-content: space-between; }
        }

        /* æ»šåŠ¨æ¡ç¾åŒ– */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
        ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
        .output-box::-webkit-scrollbar-track { background: #2d3436; }
        .output-box::-webkit-scrollbar-thumb { background: #636e72; }
    </style>
</head>
<body>

<div class="app-container">
    
    <!-- å·¦ä¾§ï¼šè¯­æ–™é¢æ¿ -->
    <div class="left-panel">
        <h2>ğŸ“‚ è®­ç»ƒè¯­æ–™</h2>
        <textarea id="corpusInput" class="corpus-auto-mobile" placeholder="åœ¨æ­¤ç²˜è´´è¯­æ–™...">
æ˜¥å¤©åˆ°äº†ï¼Œä¸‡ç‰©å¤è‹ã€‚å°è‰ä»åœŸé‡Œæ¢å‡ºå¤´æ¥ï¼ŒèŠ±å„¿åœ¨é£ä¸­è·³èˆã€‚ğŸŒ¸
ç‡•å­ä»å—æ–¹é£å›æ¥äº†ï¼Œå®ƒä»¬åœ¨å±‹æªä¸‹ç­‘å·¢ã€‚ğŸ¦
æ²³æ°´è§£å†»äº†ï¼Œå®å®å’šå’šåœ°æµå‘è¿œæ–¹ã€‚ğŸŒŠ
å°æœ‹å‹ä»¬è„±ä¸‹åšåšçš„æ£‰è¢„ï¼Œåœ¨è‰åœ°ä¸Šå¥”è·‘ï¼Œæ”¾é£ç­ã€‚ğŸª
æˆ‘ä¹Ÿæƒ³å»éƒŠæ¸¸ï¼Œçœ‹çœ‹è¿™ç¾ä¸½çš„æ˜¥å¤©ã€‚
Biology is the study of life. The cell is the basic unit of life. ğŸ§¬
        </textarea>
        
        <div class="train-actions">
            <div id="trainStatus" style="font-size:0.85rem; color:#e74c3c; margin-right:10px;">æœªè®­ç»ƒ</div>
            <button onclick="trainModels()">ğŸš€ è®­ç»ƒæ¨¡å‹</button>
        </div>
    </div>

    <!-- å³ä¾§ï¼šäº¤äº’é¢æ¿ -->
    <div class="right-panel">
        <h1>N-Gram æ–‡è‰ºå¤å…´</h1>

        <!-- 1. è¾“å‡ºå±å¹• -->
        <div class="output-wrapper">
            <div id="consoleOutput" class="output-box" onclick="focusInputIfEmptySelection()">
                <div style="color:#b2bec3; text-align:center; padding-top:20px; font-style:italic;">
                    è¯·å…ˆç‚¹å‡»å·¦ä¾§â€œè®­ç»ƒæ¨¡å‹â€ï¼Œç„¶ååœ¨æ­¤å¤„å¼€å§‹åˆ›ä½œ...
                </div>
            </div>
        </div>

        <!-- 2. ä¸­é—´æ§åˆ¶æ  (ç§»è‡³æ­¤å¤„) -->
        <div class="middle-controls">
            <div class="control-group">
                <div>
                    <input type="radio" id="modelBigram" name="modelType" value="bigram" checked> <label for="modelBigram">Bigram</label>
                    <input type="radio" id="modelTrigram" name="modelType" value="trigram"> <label for="modelTrigram">Trigram</label>
                </div>
                <label class="switch-label" title="å»¶ç»­ä¸Šæ–‡">
                    <input type="checkbox" id="continuousMode" checked> ğŸ”— è¿ç»­
                </label>
            </div>

            <div class="control-group">
                <div class="setting-group" title="AIæ¯æ¬¡ç”Ÿæˆçš„å­—æ•°">
                    <label>AIå­—æ•°:</label>
                    <input type="number" id="aiCount" value="1" min="1" max="100">
                </div>
                <button class="action-btn" onclick="triggerRandomGeneration()">ğŸ² éšæœºç”Ÿæˆ</button>
            </div>
        </div>

        <!-- 3. åº•éƒ¨è¾“å…¥æ  -->
        <div class="input-area">
            <textarea id="userCharInput" placeholder="è¾“å…¥æ–‡å­— (Enterå‘é€ï¼ŒCtrl+Enteræ¢è¡Œ)..."></textarea>
            <button onclick="processInput()" style="height: auto; align-self: stretch; font-weight:bold;">å‘é€</button>
        </div>
        
        <div style="text-align:right; font-size:0.8rem; color:#999; margin-top:5px;">
             å¿«æ·é”®: Enter å‘é€ / Ctrl+Enter æ¢è¡Œ
        </div>
    </div>
</div>

<script>
// --- å“åº”å¼é«˜åº¦è°ƒæ•´é€»è¾‘ ---

function initResponsiveResize() {
    const userResultBox = document.getElementById('userCharInput');
    const corpusBox = document.getElementById('corpusInput');

    // é€šç”¨è°ƒæ•´é«˜åº¦å‡½æ•°
    function setHeight(el, maxPixels) {
        el.style.height = 'auto'; // é‡ç½®ä»¥è·å– shrinking
        // å¦‚æœæ˜¯æ¡Œé¢ç«¯ï¼ŒcorpusBox ä¸éœ€è¦ auto-resize (ç”± CSS flex æ§åˆ¶)
        // ä½† userResultBox å§‹ç»ˆéœ€è¦
        if (el.id === 'corpusInput' && window.innerWidth > 768) {
            el.style.height = '100%'; 
            return;
        }
        
        // è®¡ç®—æ–°é«˜åº¦
        let newHeight = el.scrollHeight;
        // åº”ç”¨ CSS ä¸­å®šä¹‰çš„ max-height é™åˆ¶ (ç”¨æˆ·è¾“å…¥æ¡† ~5è¡Œï¼Œç§»åŠ¨ç«¯è¯­æ–™æ¡† ~10è¡Œ)
        // è¿™é‡Œåªæ˜¯ä¸ºäº†è®© overflow ç”Ÿæ•ˆ
        el.style.height = newHeight + 'px';
    }

    // ç›‘å¬è¾“å…¥
    userResultBox.addEventListener('input', () => setHeight(userResultBox));
    corpusBox.addEventListener('input', () => setHeight(corpusBox));

    // çª—å£å˜åŒ–æ—¶é‡ç½®
    window.addEventListener('resize', () => {
        // è§¦å‘ä¸€æ¬¡è°ƒæ•´ä»¥é€‚åº”æ–°æ¨¡å¼
        // å¯¹äº corpusInputï¼Œå¦‚æœæ˜¯æ¡Œé¢ç«¯ï¼Œæ¸…é™¤å†…è”é«˜åº¦æ ·å¼è®© CSS flex æ¥ç®¡
        if (window.innerWidth > 768) {
            corpusBox.style.height = ''; 
        } else {
            setHeight(corpusBox);
        }
        setHeight(userResultBox);
    });

    // åˆå§‹åŒ–
    if (window.innerWidth <= 768) setHeight(corpusBox);
    setHeight(userResultBox);
}

window.addEventListener('DOMContentLoaded', initResponsiveResize);


// --- N-Gram ç®—æ³•æ ¸å¿ƒ (ä¿æŒä¸å˜) ---
class Counter extends Map {
    get(key) { return super.get(key) || 0; }
    add(key, val = 1) { this.set(key, this.get(key) + val); }
}

function weightedRandom(choices, weights) {
    let total = weights.reduce((a, b) => a + b, 0);
    let randomVal = Math.random() * total;
    let cumulative = 0;
    for (let i = 0; i < choices.length; i++) {
        cumulative += weights[i];
        if (randomVal < cumulative) return choices[i];
    }
    return choices[choices.length - 1]; 
}

class SimpleNGramLMBase {
    constructor() {
        this.vocab = new Set();
        this.unigram_counts = new Counter();
        this.bigram_counts = new Map(); 
        this.trigram_counts = new Map();
        this.smoothing = 1.0;
        this.vocab_size = 0;
    }
    get_bigram_count(w1, w2) {
        if (!this.bigram_counts.has(w1)) return 0;
        return this.bigram_counts.get(w1).get(w2);
    }
    get_trigram_count(w1, w2, w3) {
        let key = w1 + "|" + w2;
        if (!this.trigram_counts.has(key)) return 0;
        return this.trigram_counts.get(key).get(w3);
    }
    getRandomChar() {
        let validChars = Array.from(this.vocab).filter(c => c !== '<s>' && c !== '</s>');
        if (validChars.length === 0) return ' '; 
        return validChars[Math.floor(Math.random() * validChars.length)];
    }
}

class SimpleBigramLM extends SimpleNGramLMBase {
    train(corpus) {
        for (let i = 0; i < corpus.length; i++) {
            let word = corpus[i];
            this.vocab.add(word);
            this.unigram_counts.add(word);
            if (i < corpus.length - 1) {
                let next_word = corpus[i+1];
                if (!this.bigram_counts.has(word)) this.bigram_counts.set(word, new Counter());
                this.bigram_counts.get(word).add(next_word);
            }
        }
        this.vocab_size = this.vocab.size;
    }
    get_probability(word, given_word) {
        let bigram_c = this.get_bigram_count(given_word, word) + this.smoothing;
        let unigram_c = this.unigram_counts.get(given_word) + this.smoothing * this.vocab_size;
        return bigram_c / unigram_c;
    }
    generate_word(given_word) {
        let next_counter = this.bigram_counts.get(given_word);
        let next_words = next_counter ? Array.from(next_counter.keys()) : [];
        if (next_words.length === 0) return '</s>';
        let probabilities = next_words.map(w => this.get_probability(w, given_word));
        return weightedRandom(next_words, probabilities); 
    }
}

class SimpleTrigramLM extends SimpleNGramLMBase {
    train(corpus) {
        for (let i = 0; i < corpus.length; i++) {
            let word = corpus[i];
            this.vocab.add(word);
            this.unigram_counts.add(word);
            if (i < corpus.length - 1) {
                let next_word = corpus[i+1];
                if (!this.bigram_counts.has(word)) this.bigram_counts.set(word, new Counter());
                this.bigram_counts.get(word).add(next_word);
            }
            if (i < corpus.length - 2) {
                let next_word = corpus[i+1];
                let next_next_word = corpus[i+2];
                let bigram_key = word + "|" + next_word;
                if (!this.trigram_counts.has(bigram_key)) this.trigram_counts.set(bigram_key, new Counter());
                this.trigram_counts.get(bigram_key).add(next_next_word);
            }
        }
        this.vocab_size = this.vocab.size;
    }
    get_probability(word, given_word) {
        if (Array.isArray(given_word) && given_word.length === 2) {
            let [w1, w2] = given_word;
            let trigram_c = this.get_trigram_count(w1, w2, word) + this.smoothing;
            let bigram_c = this.get_bigram_count(w1, w2) + this.smoothing * this.vocab_size;
            return trigram_c / bigram_c;
        } else {
            let bg_count = this.get_bigram_count(given_word, word) + this.smoothing;
            let ug_count = this.unigram_counts.get(given_word) + this.smoothing * this.vocab_size;
            return bg_count / ug_count;
        }
    }
    generate_word(given_word) {
        let next_words = [];
        if (Array.isArray(given_word) && given_word.length === 2) {
            let key = given_word[0] + "|" + given_word[1];
            let counter = this.trigram_counts.get(key);
            if (counter) next_words = Array.from(counter.keys());
            else return this.generate_word(given_word[1]);
        } else {
            let counter = this.bigram_counts.get(given_word);
            if (counter) next_words = Array.from(counter.keys());
        }
        if (next_words.length === 0) return '</s>';
        let probabilities = next_words.map(w => this.get_probability(w, given_word));
        return weightedRandom(next_words, probabilities);
    }
}

// --- å…¨å±€çŠ¶æ€ ---
let bigramModel = null;
let trigramModel = null;
let isTrained = false;
let sessionHistory = ['<s>']; 
let currentDOMContainer = null;

// --- ç•Œé¢é€»è¾‘ ---

function scrollToBottom() {
    const box = document.getElementById('consoleOutput');
    box.scrollTop = box.scrollHeight;
}

function updateCursor() {
    if (!currentDOMContainer) return;
    const oldCursor = document.querySelector('.text-cursor');
    if (oldCursor) oldCursor.remove();
    const cursor = document.createElement('span');
    cursor.className = 'text-cursor';
    currentDOMContainer.appendChild(cursor);
}

function ensureContainer() {
    const box = document.getElementById('consoleOutput');
    const isContinuous = document.getElementById('continuousMode').checked;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å®è´¨å†…å®¹
    const hasContent = Array.from(box.childNodes).some(n => 
        (n.nodeType === 1 && n.tagName !== 'DIV' && !n.classList?.contains('text-cursor')) || 
        (n.nodeType === 1 && n.tagName === 'DIV') 
    );
    
    if (!currentDOMContainer || (!isContinuous && hasContent)) {
        if (hasContent) {
            const oldCursor = document.querySelector('.text-cursor');
            if(oldCursor) oldCursor.remove();
            const divider = document.createElement('hr');
            divider.className = "topic-divider";
            box.appendChild(divider);
        } else {
            box.innerHTML = ''; 
        }
        currentDOMContainer = document.createElement('div');
        currentDOMContainer.style.display = "inline"; 
        sessionHistory = ['<s>'];
        box.appendChild(currentDOMContainer);
    }
}

function appendText(text, type) {
    if (!currentDOMContainer) ensureContainer();
    const span = document.createElement('span');
    span.innerText = text;
    if (type === 'user') span.className = 'text-user';
    else if (type === 'model') span.className = 'text-model';
    currentDOMContainer.appendChild(span);
}

function trainModels() {
    const text = document.getElementById('corpusInput').value;
    if (!text.trim()) { alert("è¯·è¾“å…¥è®­ç»ƒæ–‡æœ¬ï¼"); return; }
    // å¤„ç† Emoji
    let charList = ['<s>', ...Array.from(text), '</s>'];
    
    const statusEl = document.getElementById('trainStatus');
    statusEl.innerText = "è®­ç»ƒä¸­...";
    statusEl.style.color = "#f39c12";

    setTimeout(() => {
        try {
            bigramModel = new SimpleBigramLM(); bigramModel.train(charList);
            trigramModel = new SimpleTrigramLM(); trigramModel.train(charList);
            isTrained = true;
            statusEl.innerText = "å·²å°±ç»ª";
            statusEl.style.color = "#27ae60";
            
            // ç¬¬ä¸€æ¬¡è®­ç»ƒåæ¸…ç©ºæ¬¢è¿è¯­
            const outBox = document.getElementById('consoleOutput');
            if (outBox.innerText.includes("è¯·å…ˆç‚¹å‡»å·¦ä¾§")) {
                outBox.innerHTML = '<div style="color:gray; text-align:center; padding-top:20px;">è¾“å…¥æ–‡å­—å¼€å§‹æ¥é¾™...</div>';
                currentDOMContainer = null;
            }
        } catch (e) {
            alert("è®­ç»ƒå‡ºé”™ï¼š" + e.message);
            statusEl.innerText = "å‡ºé”™";
            statusEl.style.color = "red";
        }
    }, 10);
}

function getModel() {
    if (!isTrained) { alert("è¯·å…ˆç‚¹å‡»å·¦ä¾§è®­ç»ƒæ¨¡å‹ï¼"); return null; }
    return document.querySelector('input[name="modelType"]:checked').value === 'bigram' ? bigramModel : trigramModel;
}

function generateNextToken() {
    const model = getModel();
    if (!model) return null;
    let nextWord;
    try {
        if (model instanceof SimpleTrigramLM) {
            let context;
            if (sessionHistory.length >= 2) {
                context = [sessionHistory[sessionHistory.length-2], sessionHistory[sessionHistory.length-1]];
            } else {
                context = sessionHistory[sessionHistory.length-1];
            }
            nextWord = model.generate_word(context);
        } else {
            let context = sessionHistory[sessionHistory.length-1];
            nextWord = model.generate_word(context);
        }

        if (nextWord === '</s>') {
            nextWord = model.getRandomChar();
        }
        
    } catch(e) { 
        nextWord = model.getRandomChar(); 
    }
    return nextWord;
}

function triggerRandomGeneration() {
    if (!isTrained) { alert("è¯·å…ˆè®­ç»ƒæ¨¡å‹"); return; }
    ensureContainer();
    const length = parseInt(document.getElementById('aiCount').value) || 20; 
    for (let i = 0; i < length; i++) {
        let w = generateNextToken();
        sessionHistory.push(w);
        appendText(w, 'model');
    }
    updateCursor();
    scrollToBottom();
}

function processInput() {
    if (!isTrained) { alert("è¯·å…ˆè®­ç»ƒæ¨¡å‹"); return; }

    const inputEl = document.getElementById('userCharInput');
    const val = inputEl.value;
    if (!val) return;

    let aiCount = parseInt(document.getElementById('aiCount').value);
    if (isNaN(aiCount) || aiCount < 1) aiCount = 1;

    ensureContainer();

    // 1. ä¸Šå±ç”¨æˆ·è¾“å…¥
    const chars = Array.from(val);
    chars.forEach(c => {
        sessionHistory.push(c);
        appendText(c, 'user');
    });

    // 2. ç”Ÿæˆ AI å›å¤
    for (let i = 0; i < aiCount; i++) {
        let nextW = generateNextToken();
        sessionHistory.push(nextW);
        appendText(nextW, 'model');
    }

    updateCursor();
    scrollToBottom();

    inputEl.value = '';
    inputEl.focus();
    // è§¦å‘é«˜åº¦é‡ç½®
    inputEl.style.height = 'auto';
    inputEl.style.height = inputEl.scrollHeight + 'px';
}

// é”®ç›˜ç›‘å¬
document.getElementById('userCharInput').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const start = this.selectionStart;
            const end = this.selectionEnd;
            const value = this.value;
            this.value = value.substring(0, start) + "\n" + value.substring(end);
            this.selectionStart = this.selectionEnd = start + 1;
            this.dispatchEvent(new Event('input')); // è§¦å‘ auto-resize
        } else {
            e.preventDefault(); 
            processInput();
        }
    }
});

function focusInputIfEmptySelection() {
    const selection = window.getSelection();
    if (selection.toString().length === 0) {
        document.getElementById('userCharInput').focus();
    }
}

</script>

</body>
</html>